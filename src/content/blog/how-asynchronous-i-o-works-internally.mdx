---
title: "How Asynchronous I/O Works Internally in Rust  ?"
date: "2025-08-29"
excerpt: "You know it's about non-blocking, but the real magic is in the cooperation between the programming language, the runtime, and the operating system..."
tags: ["OS", "Rust"]
author: "Shivraj Soni"
featured: false
---

# Async in Rust: Reactor, Future, and Executor

Rustâ€™s `async` is not some black-box magic.  
Itâ€™s a **3-layer system** that uses the operating system, language features, and a runtime to let you handle thousands of tasks without burning thousands of threads.  

Weâ€™ll break it down step by step.

---

## 1. Reactor Pattern (OS Level)

At the bottom, the **operating system** provides an efficient way to monitor many I/O events at once.

Instead of looping and asking:
> "Hey socket, got data yet? No? How about now? Now??"

We ask the OS:
> "Hereâ€™s a list of sockets. Please wake me up when any of them is ready."

This is called the **Reactor Pattern**.

- **Linux:** `epoll`  
- **macOS/BSD:** `kqueue`  
- **Windows:** IOCP (slightly different, Proactor style)  
- **Old times:** `select` / `poll`  

### Example flow (with epoll):
1. Register file descriptors/sockets with `epoll`.  
2. Call `epoll_wait()` â†’ runtime goes to sleep.  
3. OS wakes it up when an event happens.  
4. Runtime dispatches the right handler for that event.  

ðŸ‘‰ Thatâ€™s how a single thread can handle **10,000 connections** without collapsing.

---

## 2. Futures (Language Level)

When you write this in Rust:

```rust
async fn fetch_data() -> String {
    "Hello".to_string()
}
```

## The Executor: Driving Futures to Completion 

So far, weâ€™ve seen how the **Reactor** (OS-level event notification) and **Futures** (Rust state machines) fit into async programming.  
But thereâ€™s still one missing piece:  

ðŸ‘‰ **Who keeps polling the futures until theyâ€™re done?**  

Thatâ€™s the **Executor**.  
Think of it as the **event loop** of your async program.

---

## How the Executor Works

Hereâ€™s the step-by-step cycle:

1. **Keep a queue of tasks (futures).**  
   These are all the computations waiting to run.

2. **Pick one task â†’ call `poll()`.**  
   This checks if the future can make progress.

3. **If itâ€™s `Ready` â†’ itâ€™s done.**  
   The result is available, and the task can be removed.

4. **If itâ€™s `Pending` â†’ park it until its Waker fires.**  
   The future isnâ€™t ready yet (maybe waiting on I/O).  
   It hands the executor a **Waker**, saying:  
   > "When my socket/data is ready, call me again."

5. **If nothing is ready â†’ nap.**  
   The executor calls the OS (`epoll_wait()` on Linux, `kqueue` on macOS, `IOCP` on Windows) and sleeps.  
   No CPU is wasted.

6. **When the OS signals readiness â†’ wake the right task.**  
   That task is put back into the runnable queue.

7. **Repeat forever.**  
   This loop is efficient, non-blocking, and lets thousands of tasks share just a few threads.

---

## Simple Analogy

Imagine a teacher (Executor) with a class full of students (Futures).  

- The teacher goes desk to desk asking:  
  > "Are you done with your homework?"  
- If a student says **"Yes" (Ready)** â†’ check the homework and move on.  
- If a student says **"Not yet" (Pending)** â†’ the student raises their hand (Waker) when theyâ€™re ready.  
- If nobody is ready, the teacher takes a nap until someone calls them.

Thatâ€™s basically async Rust.

---

### In Summary

The **Executor** is the engine that drives async Rust:

- It runs a queue of tasks.
- It polls futures until theyâ€™re done.
- It cooperates with the OS Reactor (`epoll`, `kqueue`, `IOCP`) to avoid wasting CPU.
- It uses **Wakers** to know when a task should be retried.

âš¡ Without the Executor, futures would never make progress.  

---

```rust
// Pseudo-code of an Executor loop
loop {
    if let Some(task) = runnable_queue.pop() {
        match task.poll() {
            Ready(val) => println!("Task finished: {:?}", val),
            Pending => park_task(task), // waits for Waker
        }
    } else {
        // No tasks ready â†’ wait for OS to signal
        os_reactor_wait();
    }
}
``` 
Thnx for read
